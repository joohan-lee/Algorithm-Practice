#실전문제1. 1로만들기

# 1. x가 5로 나누어떨어지면 5로 나누기.
# 2. x가 3으로 나누어떨어지면 3으로 나누기.
# 3. x가 2로 나누어떨어지면 2로 나누기.
# 4. x에서 1을 빼기.

#x를 위 4개연산으로 1을 만들기.
#최소 연산 횟수는?

x = int(input())

d = [0] * 30001

for i in range(2, x+1):
  #현재의 수에서 1을 빼는 경우
  d[i] = d[i-1] + 1

  #현재의 수가 2로 나누어 떨어지는 경우
  if i % 2 == 0:
    d[i] = min(d[i],d[i//2]+1)
  
  #현재의 수가 3으로 나누어 떨어지는 경우
  if i % 3 == 0:
    d[i] = min(d[i], d[i // 3] + 1)

  if i % 5 == 0:
    d[i] = min(d[i],d[i // 5] + 1)

print(d[x])


#======================================================================

#실전문제 2. 개미 전사
#한칸 떨어져 있는 수들의 합 중 최대값 구하기

n = int(input())

d = [0] * 100

array = list(map(int,input().split()))

d[0] = array[0]
d[1] = max(d[0], array[1])

for i in range(2, n):
 d[i] = max(d[i-1], d[i-2] + array[i])
 
print(d[n-1]) 


#=============================================================================
#실전문제 3. 바닥 공사
# 작은 타일을 이용해 바닥을 채우기.
# 1X2, 2X1, 2X2 타일을 이용해 2 X N 바닥을 채우는 모든 경우의 수?

#왼쪽부터 채워간다고 생각하고 i - 1, i - 2번째 경우를 생각해보자
#점화식 : a(i) = a(i-1) + a(i-2) * 2
#최대크기가 2 X 2이므로 위와같은 점화식이 나온다.

n = int(input())

d = [0] * 1001

d[1] = 1
d[2] = 3

for i in range(3, n+1):
  d[i] = (d[i-1] + d[i-2] * 2) % 796796

print(d[n])


#================================================================================
#실전문제4. 효율적인 화폐 구성
# N종류의 화폐를 이용하여 M원을 만들고자 할때,
# 최소 화폐 개수는? (1<=N<=100, 1<=M<=10000)

n, m = map(int, input().split())

paper = []
for i in range(n):
  paper.append(int(input())) #N종류의 화폐 가치


d = [10001] * (m+1)

d[0] = 0
for i in range(n):
  for j in range(paper[i],m+1): #화폐 단위마다 만들 수 있는 개수 계산
    if d[j - paper[i]] != 10001: #(i-k)원을 만드는 방법이 존재하는 경우
      d[j] = min(d[j], d[j-paper[i]] + 1)
    
if d[m] == 10001:
  print(-1)
else:
  print(d[m])






